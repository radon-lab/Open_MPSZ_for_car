//Версия 0.0.3
//Микропроцессорное зажигание для одного ДХ со шторкой 90° и двуконтурного коммутатора

#define ENG_STOP_RPM 100 //минимальные обороты заведенного двигателя

#define CUT_OFF_RPM 5500 //остановка работы двигателя(отсечка) (обр*мин)
#define CUT_ON_RPM  5400 //возобновление работы двигателя после отсечки (обр*мин)

#define IDLE_OFF_RPM 800 //минимальное значение признака ХХ (обр*мин)
#define IDLE_ON_RPM  1100 //максимальное значение признака ХХ (обр*мин)

#define IDLE_RPM_MIN 875 //минимальное значение ХХ (обр*мин)
#define IDLE_RPM_MAX 925 //максимальное значение ХХ (обр*мин)

#define IDLE_UOZ_MIN     0  //минимальное значение коррекции УОЗ ХХ (0..10)(°)
#define IDLE_UOZ_MAX     10 //максимальное значение коррекции УОЗ ХХ (5..25)(°)
#define IDLE_UOZ_DEFAULT 5  //значение коррекции УОЗ ХХ при старте (0..25)(°)

#define DET_TEMP_ENG_MIN -45 //минимальное значение температуры двигателя (-45..119) (°с)
#define DET_TEMP_ENG_MAX 119 //максимальное значение температуры двигателя (-45..119) (°с)
#define ADC_DET_TEMP_MIN 0 //минимальное значение АЦП датчика температуры двигателя (0..255)
#define ADC_DET_TEMP_MAX 255 //максимальное значение АЦП датчика температуры двигателя (0..255)

#define DDR_REG(portx)  (*(&portx-1))

//пин Датчика Холла
#define DET_BIT   2 // D2
#define DET_PORT  PORTD
#define DET_PIN   PIND

#define DET_STATE (bitRead(DET_PIN, DET_BIT))
#define DET_SET   (bitSet(DET_PORT, DET_BIT))
#define DET_INP   (bitClear((DDR_REG(DET_PORT)), DET_BIT))

#define DET_INIT  DET_SET; DET_INP

//пин коммутатора D5
#define COM_BIT   5 // D5
#define COM_PORT  PORTD

#define COM_CLR   (bitClear(COM_PORT, COM_BIT))
#define COM_SET   (bitSet(COM_PORT, COM_BIT))
#define COM_OUT   (bitSet((DDR_REG(COM_PORT)), COM_BIT))

#define COM_INIT  COM_CLR; COM_OUT

int8_t UOZ_rpm_table [100] = { //значениея УОЗ в зависимости от оборотов двигателя 1яч - 100обр*мин (0..9900)(обр*мин), значиния в ячейке (-15..75)(°)

  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //0 - 900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //1000 - 1900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //2000 - 2900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //3000 - 3900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //4000 - 4900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //5000 - 5900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //6000 - 6900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //7000 - 7900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //8000 - 8900
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0  //9000 - 9900

};

int8_t UOZ_temp_table [165] = { //значениея УОЗ в зависимости от температуры 1яч - 1°с (-45..120)(°с), значиния в ячейке (-15..75)(°)

  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //-45 - -31
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //-30 - -16
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //-15 - -1
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //0 - 14
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //15 - 29
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //30 - 44
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //45 - 59
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //60 - 74
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //75 - 89
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //90 - 104
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  //105 - 119

};

volatile uint16_t _micros = 0; //счетчик микросекунд
volatile uint16_t _micros_phase = 0; //временный буфер одной фазы сигнала ДХ

uint16_t rev_per_min = 0; //обороты в минуту
uint16_t _deg_dellay = 0; //задержка микросекуд для опережения зажигания
uint16_t _micros_phase_old = 0; //предыдущее состояние временного буфера фазы

uint8_t _idle_uoz_correct = IDLE_UOZ_DEFAULT; //коррекция оборотов ХХ

boolean eng_flag = 1; //флаг работы системы зажигания
boolean idle_flag = 0; //флаг ХХ двигателя

int atexit(void (* /*func*/ )()) { //инициализация функций
  return 0;
}
//--------------------------------------Инициализация---------------------------------------------------
int main(void)  //инициализация
{
  DET_INIT; //инициализация ДХ
  COM_INIT; //инициализация коммутатора

  EICRA = 0b00000101; //настраиваем внешнее прерывание по любому изменению сигнала на INT0 и INT1
  TCCR0A = 0b00000000; //отключаем OC0A/OC0B
  TCCR0B = 0b00000001; //пределитель 1

  while (!EIFR); //ждем старта двигателя

  _deg_dellay = _calc_current_dellay(IDLE_UOZ_DEFAULT);

  TIMSK0 = 0b00000001; //включаем прерывания Таймера0 (16us)
  EIMSK = 0b00000001; //разрешаем внешнее прерывание INT0

  //----------------------------------Главная-------------------------------------------------------------
  for (;;) //главная
  {
    if (_micros_phase != _micros_phase_old) { //если старая фаза не равна новой
      _micros_phase_old = _micros_phase; //запоминаем старое значение фазы
      rev_per_min = (1000.00 / ((float)_micros_phase * 2.00 * 16.00 / 1000.00)) * 60.00; //получаем обороты в минуту
      if (rev_per_min > 9900) rev_per_min = 9900; //если обороты превысили предел, ограничиваем их

      if (rev_per_min > IDLE_ON_RPM || rev_per_min < IDLE_OFF_RPM) idle_flag = 0; //если обороты двигтеля больше или меньше диапазона ХХ, тогда выключаем признак ХХ
      else idle_flag = 1; //иначе поднимаем флаг признака ХХ

      if (rev_per_min >= CUT_OFF_RPM) _deg_dellay = eng_flag = 0; //если обороты превысили порог, значит отключаем управление коммутатором
      else if (rev_per_min <= CUT_ON_RPM) eng_flag = 1; //иначе если обороты упали ниже нижнего порога, значит включаем управление коммутатором

      if (eng_flag) { //если зажигание активно
        if (idle_flag) { //если стоит признак ХХ
          if (rev_per_min > IDLE_RPM_MAX && _idle_uoz_correct < IDLE_UOZ_MAX) _idle_uoz_correct++; //если обороты двигателя выше установки ХХ, увеличиваем значение коррекции УОЗ
          if (rev_per_min < IDLE_RPM_MIN && _idle_uoz_correct > IDLE_UOZ_MIN) _idle_uoz_correct--; //если обороты двигателя ниже установки ХХ, уменьшаем значение коррекции УОЗ
        }
      }
    }
    if (eng_flag) { //если зажигание активно
      uint8_t temp = 45 + map ((int8_t)_read_temp_eng_sensor(), ADC_DET_TEMP_MIN, ADC_DET_TEMP_MAX, ADC_DET_TEMP_MIN, ADC_DET_TEMP_MAX); //получаем температуру двигателя с датчика

      uint8_t UOZ_now = ((int8_t)75 - UOZ_rpm_table[rev_per_min / 100]) + ((int8_t)75 - UOZ_temp_table[temp]) + _idle_uoz_correct; //рассчитываем текущий УОЗ
      if (UOZ_now > 90) UOZ_now = 90; //ограничиваем максимум УОЗ

      _deg_dellay = _calc_current_dellay(UOZ_now); //расчитываем количество тиков задержки в зависимости от оборотов и указанного угла опережения в таблице
    }
    if (_micros == 65535) {
      _deg_dellay = _calc_current_dellay(IDLE_UOZ_DEFAULT); //если двигатель заглох, устанавливаем УОЗ по умолчанию
      while (_micros == 65535); //ждем старта двигателя
    }
  }
  return 0; //конец
}
//---------------------------------Рассчет задержки импульса зажигания---------------------------------------
uint16_t _calc_current_dellay(uint8_t uoz) //рассчет задержки импульса зажигания
{
  return (float)_micros_phase / 90.00 * uoz;
}
//-------------------------------Детектирование импульсов ДХ------------------------------------------------
ISR(INT0_vect) //внешнее прерывание на пине INT0 - детектирование импульсов ДХ
{
  _micros_phase = _micros; //записываем фазу во временный буфер
  _micros = 0; //сбрасываем счетчик микросекунд
}
//---------------------------------Счетчик микросекунд---------------------------------------
ISR(TIMER0_OVF_vect) //счетчик микросекунд(1 прерывание - 16us)
{
  if (_micros != 65535) ++_micros; //защита от переполнения
  if (_micros == _deg_dellay) { //если пришло время выдать сигнал
    switch (DET_STATE) { //устанавливаем пин коммутатора в зависимости от состояния ДХ
      case 0: COM_CLR; break; //спадающий фронт
      case 1: COM_SET; break; //нарастающий фронт
    }
  }
}
//---------------------------------Чтение значения датчика температуры двигателя---------------------------------------
uint8_t _read_temp_eng_sensor(void) //чтение значения датчика температуры двигателя
{
  uint16_t result = 0; //результат опроса АЦП

  ADMUX = 0b01100110; //выбор внешнего опорного 5В и порта А6
  ADCSRA = 0b11100111; //настройка АЦП

  for (uint8_t i = 0; i < 10; i++) { //делаем 10 замеров
    while ((ADCSRA & 0x10) == 0); //ждем флага прерывания АЦП
    ADCSRA |= 0x10; //сбрасываем флаг прерывания
    result += ADCH; //прибавляем замер в буфер
  }
  result /= 10; //находим среднее значение
  return result; //возвращаем результат опроса АЦП
}
//---------------------------------Чтение значения датчика абсолютного давления---------------------------------------
uint8_t _read_pressur_sensor(void) //чтение значения датчика абсолютного давления
{
  uint16_t result = 0; //результат опроса АЦП

  ADMUX = 0b01100101; //выбор внешнего опорного 5В и порта А5
  ADCSRA = 0b11100111; //настройка АЦП

  for (uint8_t i = 0; i < 10; i++) { //делаем 10 замеров
    while ((ADCSRA & 0x10) == 0); //ждем флага прерывания АЦП
    ADCSRA |= 0x10; //сбрасываем флаг прерывания
    result += ADCH; //прибавляем замер в буфер
  }
  result /= 10; //находим среднее значение
  return result; //возвращаем результат опроса АЦП
}
//---------------------------------Чтение значения датчика температуры впускного воздуха---------------------------------------
uint8_t _read_temp_int_sensor(void) //чтение значения датчика температуры впускного воздуха
{
  uint16_t result = 0; //результат опроса АЦП

  ADMUX = 0b01100100; //выбор внешнего опорного 5В и порта А4
  ADCSRA = 0b11100111; //настройка АЦП

  for (uint8_t i = 0; i < 10; i++) { //делаем 10 замеров
    while ((ADCSRA & 0x10) == 0); //ждем флага прерывания АЦП
    ADCSRA |= 0x10; //сбрасываем флаг прерывания
    result += ADCH; //прибавляем замер в буфер
  }
  result /= 10; //находим среднее значение
  return result; //возвращаем результат опроса АЦП
}
//---------------------------------Чтение значения датчика детонации---------------------------------------
uint8_t _read_knock_sensor(void) //чтение значения датчика детонации
{
  uint16_t result = 0; //результат опроса АЦП

  ADMUX = 0b01100011; //выбор внешнего опорного 5В и порта А3
  ADCSRA = 0b11100111; //настройка АЦП

  for (uint8_t i = 0; i < 10; i++) { //делаем 10 замеров
    while ((ADCSRA & 0x10) == 0); //ждем флага прерывания АЦП
    ADCSRA |= 0x10; //сбрасываем флаг прерывания
    result += ADCH; //прибавляем замер в буфер
  }
  result /= 10; //находим среднее значение
  return result; //возвращаем результат опроса АЦП
}
